#include <iostream> // импортируем библиотеку для ввода-вывода
#include <string> // импортируем библиотеку для работы со строками
#include <vector> // импортируем библиотеку для работы с динамическими массивами
#include <windows.h> // для установки кодировки консоли

class Unit { // создаем родительский класс Unit
protected: // модификатор доступа protected, чтобы классы наследники могли использовать эти поля
	std::string name; // создаем переменную для имени юнита
	int health; // создаем переменную для здоровья юнита
	int damage; // создаем переменную для урона юнита

public: // модификатор доступа public, чтобы методы были доступны как и в классах наследниках, так и вне классов вовсе

	Unit(std::string n, int h, int d) { // создаем конструктор класса Unit, который принимает имя, здоровье и урон юнита
		name = n; // присваиваем значение имени
		health = h; // присваиваем значение здоровья
		damage = d; // присваиваем значение урона

    }
    virtual void TakeDamage(int dmg) { // создаем виртуальный метод для получения урона, который принимает урон
		health -= dmg; // уменьшаем здоровье на полученный урон
		std::cout << "Юнит " << name << " получил " << dmg << " урона. Текущее здоровье: " << health << std::endl; // выводим текст
    }

    virtual void Attack() { // создаем виртуальный метод для атаки
		std::cout << "Юнит " << name << " атакует, нанося " << damage << " урона." << std::endl; // выводим текст
    }

    virtual ~Unit() {} // создаем виртуальный деструктор, чтобы память очищалась корректно
};

class Warrior : public Unit { // создаем класс Warrior, который наследует класс Unit
public: // публичный модификатор доступа
	Warrior(std::string n) : Unit(n, 100, 15) {} // создаем конструктор класса Warrior, который принимает лишь имя и передает родительскому конструктору имя, здоровье и урон
    
    void Attack() override { // переопределяем метод атаки
        std::cout << "Воин по именни " << name << " атакует противника своим мечем, нанося ему " << damage << " физического урона." << std::endl; // выводим текст
    }
};

class Mage : public Unit { // создаем класс Mage, который наследует класс Unit
public:// публичный модификатор доступа
	Mage(std::string n) : Unit(n, 60, 40) {} // создаем конструктор класса Mage, который принимает лишь имя и передает родительскому конструктору имя, здоровье и урон

	void Attack() override { // переопределяем метод атаки
		std::cout << "Маг по именни " << name << " накладывает на врага проклятие, нанося ему " << damage << " магического урона." << std::endl; // выводим текст
    }
};

class Ork : public Unit { // создаем класс Ork, который наследует класс Unit
public: // публичный модификатор доступа
	Ork(std::string n) : Unit(n, 100, 20) {} // создаем конструктор класса Ork, который принимает лишь имя и передает родительскому конструктору имя, здоровье и урон

	void Attack() override { // переопределяем метод атаки
		std::cout << "Орк по именни " << name << " свирепо накидывается на врага, нанося ему " << damage << " физического урона." << std::endl; // выводим текст
        }
};

int main() // главная функция программы
{
	SetConsoleCP(CP_UTF8); // устанавливаем кодировку консоли на UTF-8
	SetConsoleOutputCP(CP_UTF8); // устанавливаем кодировку консоли на UTF-8

    std::vector<Unit*> arena; // создаем динамический масив указателей на Unit
	arena.push_back(new Warrior("Jhon")); // добавляем в конец массива новый объект класса Warrior и передаем его имя
	arena.push_back(new Mage("Gandalf")); // добавляем в конец массива новый объект класса Mage и передаем его имя
	arena.push_back(new Ork("Benny")); // добавляем в конец массива новый объект класса Ork и передаем его имя
	arena.push_back(new Warrior("Dave")); // добавляем в конец массива новый объект класса Warrior и передаем его имя

    for (int i = 0; i < arena.size(); i++) { // проходимся по каждому елементу масива
        arena[i]->Attack(); // вызываем метод атаки для каждого юнита
    }

    for (int i = 0; i < arena.size(); i++) { // проходимся по каждому елементу масива
		delete arena[i]; // очищаем память для каждого юнита
    }


    arena.clear(); // очищаем масив
    return 0; // конец главной функции программы
}